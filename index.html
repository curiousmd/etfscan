<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ETF Holdings Aggregator â€“ Equities Only</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      color: #111827;
      background: #f3f4f6;
    }
    body {
      margin: 0;
      padding: 24px 12px 40px;
      display: flex;
      justify-content: center;
    }
    .app {
      width: 100%;
      max-width: 900px;
      background: #ffffff;
      border-radius: 18px;
      padding: 24px 24px 32px;
      box-shadow: 0 16px 40px rgba(15, 23, 42, 0.12);
    }
    h1 {
      margin: 0 0 4px;
      font-size: 1.6rem;
    }
    .subtitle {
      margin: 0 0 20px;
      color: #6b7280;
      font-size: 0.95rem;
    }
    .small {
      font-size: 0.8rem;
      color: #6b7280;
    }
    .mt-4 { margin-top: 4px; }
    .mt-8 { margin-top: 8px; }
    .mt-16 { margin-top: 16px; }
    .mt-24 { margin-top: 24px; }
    .mt-32 { margin-top: 32px; }

    label {
      font-size: 0.85rem;
      font-weight: 600;
      display: block;
      margin-bottom: 6px;
    }

    input[type="file"] {
      font-size: 0.9rem;
    }

    button {
      border-radius: 999px;
      border: none;
      padding: 9px 18px;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      box-shadow: 0 8px 20px rgba(15, 23, 42, 0.12);
      transition: transform 0.1s, box-shadow 0.1s, background 0.1s;
    }
    button.primary {
      background: #4f46e5;
      color: #ffffff;
    }
    button.secondary {
      background: #e5e7eb;
      color: #111827;
      box-shadow: none;
    }
    button:active {
      transform: translateY(1px);
      box-shadow: 0 4px 10px rgba(15, 23, 42, 0.2);
    }
    button:disabled {
      opacity: 0.6;
      cursor: default;
      box-shadow: none;
      transform: none;
    }

    textarea {
      width: 100%;
      border-radius: 10px;
      border: 1px solid #d1d5db;
      padding: 10px 12px;
      font-size: 0.9rem;
      box-sizing: border-box;
      min-height: 80px;
      resize: vertical;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      background: #f9fafb;
    }
    textarea:focus {
      outline: none;
      border-color: #4f46e5;
      box-shadow: 0 0 0 1px rgba(79, 70, 229, 0.4);
      background: #ffffff;
    }

    .status {
      margin-top: 6px;
      font-size: 0.83rem;
    }
    .status.error { color: #b91c1c; }
    .status.ok { color: #15803d; }

    .file-summary {
      margin-top: 8px;
      padding: 8px 10px;
      border-radius: 10px;
      background: #f9fafb;
      border: 1px solid #e5e7eb;
      font-size: 0.8rem;
    }
    .file-summary-item {
      margin-bottom: 4px;
    }

    @media (max-width: 640px) {
      .app {
        padding: 18px 14px 24px;
        border-radius: 0;
        box-shadow: none;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <h1>ETF Holdings Aggregator</h1>
    <p class="subtitle">
      Upload one or more CSV files downloaded from ETF websites (BOUT, FFTY,
      QMOM, etc.). This tool extracts <strong>only stock (equity) tickers</strong>
      and aggregates them into a single comma-separated list (no ETFs, no options,
      no CUSIPs, no quotes).
    </p>

    <!-- File upload -->
    <div>
      <label for="filesInput">Holdings CSV files</label>
      <input
        type="file"
        id="filesInput"
        accept=".csv,.txt"
        multiple
      />
      <p class="small mt-4">
        You can select multiple files at once (e.g., BOUT.csv, FFTY.csv,
        QMOM.csv). The tool auto-detects the ticker column and a name/description
        column. It then keeps only stock-like tickers whose security name does
        <strong>not</strong> look like an ETF or fund.
      </p>

      <div id="fileSummary" class="file-summary" style="display:none;"></div>

      <div class="mt-16">
        <button id="aggregateBtn" class="primary">ðŸ”„ Aggregate tickers</button>
        <span id="status" class="status"></span>
      </div>
    </div>

    <!-- Output -->
    <div class="mt-32">
      <h2 style="font-size:1.15rem; margin:0 0 8px;">Comma-separated tickers</h2>
      <p class="small" style="margin:0 0 8px;">
        Unique equity tickers from all uploaded files (sorted alphabetically, no quotes, ETFs removed).
      </p>

      <label for="commaOutput" style="margin-bottom:4px;">Output</label>
      <textarea id="commaOutput" placeholder="AAPL, MSFT, NVDA, ..."></textarea>

      <div class="mt-8">
        <button id="copyBtn" class="secondary">
          ðŸ“‹ Copy comma-separated tickers
        </button>
      </div>
    </div>
  </div>

  <script>
    const filesInput = document.getElementById("filesInput");
    const aggregateBtn = document.getElementById("aggregateBtn");
    const copyBtn = document.getElementById("copyBtn");
    const statusEl = document.getElementById("status");
    const fileSummaryEl = document.getElementById("fileSummary");
    const commaOutputEl = document.getElementById("commaOutput");

    // Store parsed tickers per file
    let parsedFiles = [];

    function setStatus(msg, type = "") {
      statusEl.textContent = msg || "";
      statusEl.className = "status" + (type ? " " + type : "");
    }

    // Decide if a ticker string is a stock-like ticker (pattern only)
    function normalizeEquityTicker(raw) {
      if (!raw) return null;
      let t = String(raw).trim();
      if (!t) return null;

      // Strip wrapping quotes
      if (
        (t.startsWith('"') && t.endsWith('"')) ||
        (t.startsWith("'") && t.endsWith("'"))
      ) {
        t = t.slice(1, -1);
      }

      t = t.trim();
      if (!t) return null;

      // Take only the first token before whitespace
      let base = t.split(/\s+/)[0];
      base = base.trim().toUpperCase();
      if (!base) return null;

      // Filter out obvious non-tickers
      const blacklistExact = new Set([
        "CASH",
        "OTHER",
        "CASH&OTHER",
        "NA"
      ]);
      if (blacklistExact.has(base)) return null;
      if (base.includes("&")) return null; // anything like CASH&OTHER

      // Share-class symbols with slash (e.g. BRK/B, HEI/A, CWEN/A)
      const shareClassSlash = /^[A-Z]{1,4}\/[A-Z]$/;
      // Simple equity ticker: 1â€“5 letters, no digits
      const simpleEquity = /^[A-Z]{1,5}$/;

      // Money-market / fund-style like FGXXX -> reject if ends with 'XXX'
      if (/XXX$/.test(base)) return null;

      if (shareClassSlash.test(base)) {
        return base;
      }

      if (!simpleEquity.test(base)) {
        // reject anything with digits or weird punctuation
        return null;
      }

      return base;
    }

    // Decide if a row is likely an ETF/fund based on security name
    function isLikelyETF(ticker, name) {
      const n = (name || "").toLowerCase();
      if (!n) return false;

      // Strong ETF/fund indicators in the security name
      const keywords = [
        " etf",
        "exchange traded fund",
        "exchange-traded fund",
        "index fund",
        "index etf",
        "fund ",
        "fund,",
        "fund (",
        "fund-",
        "spdr ",
        "ishares",
        "vanguard",
        "invesco",
        "xtrackers",
        "wisdomtree",
        "ark ",
        "arkf",
        "arkg",
        "arkk",
        "arkq",
        "arkw"
      ];

      // We always treat explicit "etf" as ETF
      if (/\betf\b/i.test(name || "")) return true;

      for (const kw of keywords) {
        if (n.includes(kw)) return true;
      }

      // Otherwise, assume it's not an ETF
      return false;
    }

    // Detect delimiter by counting commas/semicolons/tabs in the first few lines
    function detectDelimiter(lines) {
      const candidates = [",", ";", "\t"];
      const scores = { ",": 0, ";": 0, "\t": 0 };

      const sampleLines = lines.slice(0, Math.min(lines.length, 10));
      for (const line of sampleLines) {
        for (const d of candidates) {
          const c = (line.match(new RegExp(`\\${d}`, "g")) || []).length;
          scores[d] += c;
        }
      }

      let bestDelim = ",";
      let bestScore = -1;
      for (const d of candidates) {
        if (scores[d] > bestScore) {
          bestScore = scores[d];
          bestDelim = d;
        }
      }
      return bestDelim;
    }

    // Try to find a header row and ticker column index by header name
    function findHeaderAndTickerIndex(lines, delimiter) {
      const maxHeaderScan = Math.min(lines.length, 15);
      const headerPatterns = /(ticker|symbol|underlying)/i;

      for (let i = 0; i < maxHeaderScan; i++) {
        const cols = lines[i].split(delimiter).map((c) => c.trim());
        for (let j = 0; j < cols.length; j++) {
          if (headerPatterns.test(cols[j])) {
            return { headerRowIndex: i, tickerIdx: j };
          }
        }
      }
      return { headerRowIndex: -1, tickerIdx: -1 };
    }

    // If no explicit header name, guess which column looks most like tickers
    function guessTickerColumn(lines, delimiter) {
      const maxScanLines = Math.min(lines.length, 30);
      let maxCols = 0;
      const splitLines = [];

      for (let i = 0; i < maxScanLines; i++) {
        const cols = lines[i].split(delimiter);
        splitLines.push(cols);
        if (cols.length > maxCols) maxCols = cols.length;
      }

      let bestCol = -1;
      let bestScore = -1;

      for (let col = 0; col < maxCols; col++) {
        let score = 0;
        for (let i = 0; i < splitLines.length; i++) {
          const cols = splitLines[i];
          if (col >= cols.length) continue;
          const eq = normalizeEquityTicker(cols[col]);
          if (!eq) continue;

          // Strong preference for typical equity length (<=5, letters only)
          if (/^[A-Z]{1,5}$/.test(eq)) {
            score += 3;
          } else if (/^[A-Z]{1,4}\/[A-Z]$/.test(eq)) {
            score += 2;
          } else {
            score += 1;
          }
        }
        if (score > bestScore) {
          bestScore = score;
          bestCol = col;
        }
      }

      if (bestScore <= 0) {
        return { headerRowIndex: 0, tickerIdx: 0 }; // fallback
      }

      // Assume first line is header if we got here
      return { headerRowIndex: 0, tickerIdx: bestCol };
    }

    // Parse CSV/TSV and return only equity (non-ETF) tickers
    function parseCsvForEquities(text) {
      const rawLines = text.split(/\r?\n/);
      const lines = rawLines.filter((l) => l.trim());
      if (!lines.length) return [];

      const delimiter = detectDelimiter(lines);

      // First, try to find a header row with a ticker-like header
      let { headerRowIndex, tickerIdx } = findHeaderAndTickerIndex(
        lines,
        delimiter
      );

      if (tickerIdx === -1) {
        // No obvious header names â€“ guess by equity pattern
        const guess = guessTickerColumn(lines, delimiter);
        headerRowIndex = guess.headerRowIndex;
        tickerIdx = guess.tickerIdx;
      }

      // Try to find a name/description column on the header row (if any)
      let nameIdx = -1;
      if (headerRowIndex >= 0 && headerRowIndex < lines.length) {
        const headerCols = lines[headerRowIndex]
          .split(delimiter)
          .map((c) => c.trim());
        nameIdx = headerCols.findIndex((h) =>
          /(name|description|security)/i.test(h)
        );
        if (nameIdx < 0) {
          nameIdx = -1;
        }
      }

      const startRow = Math.min(headerRowIndex + 1, lines.length);
      const tickers = [];

      for (let i = startRow; i < lines.length; i++) {
        const cols = lines[i].split(delimiter);
        if (!cols.length || tickerIdx >= cols.length) continue;

        const rawTicker = cols[tickerIdx];
        const rawName =
          nameIdx >= 0 && nameIdx < cols.length ? cols[nameIdx] : "";

        const eqTicker = normalizeEquityTicker(rawTicker);
        if (!eqTicker) continue;

        // If we have a name/description, use it to remove ETFs/funds
        if (isLikelyETF(eqTicker, rawName)) continue;

        tickers.push(eqTicker);
      }

      return tickers;
    }

    function updateFileSummary() {
      if (!parsedFiles.length) {
        fileSummaryEl.style.display = "none";
        fileSummaryEl.innerHTML = "";
        return;
      }
      fileSummaryEl.style.display = "block";
      fileSummaryEl.innerHTML = "";
      parsedFiles.forEach((pf) => {
        const div = document.createElement("div");
        div.className = "file-summary-item";
        if (pf.error) {
          div.textContent = `${pf.name}: error â€“ ${pf.error}`;
        } else {
          div.textContent = `${pf.name}: ${pf.tickers.length} equity tickers`;
        }
        fileSummaryEl.appendChild(div);
      });
    }

    function readAllFiles(files) {
      parsedFiles = [];
      setStatus("", "");
      commaOutputEl.value = "";
      fileSummaryEl.style.display = "none";
      fileSummaryEl.innerHTML = "";

      if (!files || !files.length) {
        setStatus("No files selected yet.", "error");
        return;
      }

      let remaining = files.length;

      Array.from(files).forEach((file) => {
        const reader = new FileReader();
        reader.onload = () => {
          try {
            const text = reader.result;
            const tickers = parseCsvForEquities(text);
            parsedFiles.push({ name: file.name, tickers });
          } catch (e) {
            console.error(e);
            parsedFiles.push({
              name: file.name,
              tickers: [],
              error: e.message,
            });
          } finally {
            remaining--;
            if (remaining === 0) {
              updateFileSummary();
              if (parsedFiles.some((pf) => pf.tickers.length > 0)) {
                setStatus(
                  "Files loaded. Click 'Aggregate tickers' to build the combined equity list.",
                  "ok"
                );
              } else {
                setStatus(
                  "Files loaded but no equity tickers detected â€“ check the CSV format.",
                  "error"
                );
              }
            }
          }
        };
        reader.onerror = () => {
          console.error("Error reading file:", file.name);
          parsedFiles.push({
            name: file.name,
            tickers: [],
            error: "Failed to read file",
          });
          remaining--;
          if (remaining === 0) {
            updateFileSummary();
            setStatus(
              "Some files could not be read. Check the summary above.",
              "error"
            );
          }
        };
        reader.readAsText(file);
      });
    }

    filesInput.addEventListener("change", (e) => {
      readAllFiles(e.target.files);
    });

    aggregateBtn.addEventListener("click", () => {
      if (!parsedFiles.length) {
        setStatus("No files loaded â€“ select CSV files first.", "error");
        return;
      }

      const allTickers = parsedFiles.flatMap((pf) => pf.tickers || []);
      if (!allTickers.length) {
        setStatus(
          "No equity tickers found in the loaded files.",
          "error"
        );
        return;
      }

      const unique = Array.from(new Set(allTickers)).sort();
      commaOutputEl.value = unique.join(", ");

      setStatus(
        `Aggregated ${unique.length} unique equity tickers from ${allTickers.length} total entries.`,
        "ok"
      );
    });

    copyBtn.addEventListener("click", async () => {
      const text = commaOutputEl.value.trim();
      if (!text) {
        setStatus("Nothing to copy yet.", "error");
        return;
      }
      try {
        await navigator.clipboard.writeText(text);
        setStatus("Tickers copied to clipboard âœ…", "ok");
      } catch (e) {
        console.error(e);
        setStatus("Clipboard copy failed (browser blocked it).", "error");
      }
    });
  </script>
</body>
</html>
