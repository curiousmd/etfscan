<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ETF Holdings Aggregator â€“ CSV Upload</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      color: #111827;
      background: #f3f4f6;
    }
    body {
      margin: 0;
      padding: 24px 12px 40px;
      display: flex;
      justify-content: center;
    }
    .app {
      width: 100%;
      max-width: 900px;
      background: #ffffff;
      border-radius: 18px;
      padding: 24px 24px 32px;
      box-shadow: 0 16px 40px rgba(15, 23, 42, 0.12);
    }
    h1 {
      margin: 0 0 4px;
      font-size: 1.6rem;
    }
    .subtitle {
      margin: 0 0 20px;
      color: #6b7280;
      font-size: 0.95rem;
    }
    .small {
      font-size: 0.8rem;
      color: #6b7280;
    }
    .mt-4 { margin-top: 4px; }
    .mt-8 { margin-top: 8px; }
    .mt-16 { margin-top: 16px; }
    .mt-24 { margin-top: 24px; }
    .mt-32 { margin-top: 32px; }

    label {
      font-size: 0.85rem;
      font-weight: 600;
      display: block;
      margin-bottom: 6px;
    }

    input[type="file"] {
      font-size: 0.9rem;
    }

    button {
      border-radius: 999px;
      border: none;
      padding: 9px 18px;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      box-shadow: 0 8px 20px rgba(15, 23, 42, 0.12);
      transition: transform 0.1s, box-shadow 0.1s, background 0.1s;
    }
    button.primary {
      background: #4f46e5;
      color: #ffffff;
    }
    button.secondary {
      background: #e5e7eb;
      color: #111827;
      box-shadow: none;
    }
    button:active {
      transform: translateY(1px);
      box-shadow: 0 4px 10px rgba(15, 23, 42, 0.2);
    }
    button:disabled {
      opacity: 0.6;
      cursor: default;
      box-shadow: none;
      transform: none;
    }

    textarea {
      width: 100%;
      border-radius: 10px;
      border: 1px solid #d1d5db;
      padding: 10px 12px;
      font-size: 0.9rem;
      box-sizing: border-box;
      min-height: 80px;
      resize: vertical;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      background: #f9fafb;
    }
    textarea:focus {
      outline: none;
      border-color: #4f46e5;
      box-shadow: 0 0 0 1px rgba(79, 70, 229, 0.4);
      background: #ffffff;
    }

    .status {
      margin-top: 6px;
      font-size: 0.83rem;
    }
    .status.error { color: #b91c1c; }
    .status.ok { color: #15803d; }

    .file-summary {
      margin-top: 8px;
      padding: 8px 10px;
      border-radius: 10px;
      background: #f9fafb;
      border: 1px solid #e5e7eb;
      font-size: 0.8rem;
    }
    .file-summary-item {
      margin-bottom: 4px;
    }

    @media (max-width: 640px) {
      .app {
        padding: 18px 14px 24px;
        border-radius: 0;
        box-shadow: none;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <h1>ETF Holdings Aggregator</h1>
    <p class="subtitle">
      Upload one or more CSV files downloaded from ETF websites (BOUT, FFTY,
      QMOM, etc.). This tool will extract all tickers from those files and
      aggregate them into a single comma-separated list.
    </p>

    <!-- File upload -->
    <div>
      <label for="filesInput">Holdings CSV files</label>
      <input
        type="file"
        id="filesInput"
        accept=".csv,.txt"
        multiple
      />
      <p class="small mt-4">
        You can select multiple files at once (for example, BOUT.csv, FFTY.csv,
        QMOM.csv). The tool will try to detect the ticker column automatically
        (prefers a header named <code>Ticker</code> or <code>Symbol</code>, otherwise
        it uses the first column).
      </p>

      <div id="fileSummary" class="file-summary" style="display:none;"></div>

      <div class="mt-16">
        <button id="aggregateBtn" class="primary">ðŸ”„ Aggregate tickers</button>
        <span id="status" class="status"></span>
      </div>
    </div>

    <!-- Output -->
    <div class="mt-32">
      <h2 style="font-size:1.15rem; margin:0 0 8px;">Comma-separated tickers</h2>
      <p class="small" style="margin:0 0 8px;">
        Unique tickers from all uploaded files (sorted alphabetically).
      </p>

      <label for="commaOutput" style="margin-bottom:4px;">Output</label>
      <textarea id="commaOutput" placeholder="AAPL, MSFT, ..."></textarea>

      <div class="mt-8">
        <button id="copyBtn" class="secondary">
          ðŸ“‹ Copy comma-separated tickers
        </button>
      </div>
    </div>
  </div>

  <script>
    const filesInput = document.getElementById("filesInput");
    const aggregateBtn = document.getElementById("aggregateBtn");
    const copyBtn = document.getElementById("copyBtn");
    const statusEl = document.getElementById("status");
    const fileSummaryEl = document.getElementById("fileSummary");
    const commaOutputEl = document.getElementById("commaOutput");

    // Store parsed tickers per file
    let parsedFiles = [];

    function setStatus(msg, type = "") {
      statusEl.textContent = msg || "";
      statusEl.className = "status" + (type ? " " + type : "");
    }

    function sanitizeTicker(raw) {
      if (!raw) return null;
      const t = String(raw).trim().toUpperCase();
      if (!t) return null;
      // Require at least one letter Aâ€“Z to avoid pure numbers/junk
      if (!/[A-Z]/.test(t)) return null;
      return t;
    }

    // Simple CSV/TSV parser that:
    // - Detects delimiter (comma, semicolon, or tab)
    // - Looks for a header with "Ticker" or "Symbol"
    // - Falls back to first column if nothing matches
    function parseCsvForTickers(text) {
      const lines = text.split(/\r?\n/).filter((l) => l.trim());
      if (!lines.length) return [];

      // Detect delimiter using header line
      const headerLine = lines[0];
      let delimiter = ",";
      if (headerLine.indexOf("\t") !== -1) {
        delimiter = "\t";
      } else if (headerLine.indexOf(";") !== -1) {
        delimiter = ";";
      }

      const header = headerLine.split(delimiter).map((h) => h.trim());
      let tickerIdx = header.findIndex((h) =>
        /^(ticker|symbol)$/i.test(h)
      );
      if (tickerIdx === -1) {
        // Fallback: first column
        tickerIdx = 0;
      }

      const tickers = [];
      for (let i = 1; i < lines.length; i++) {
        const cols = lines[i].split(delimiter);
        if (!cols.length) continue;
        const t = sanitizeTicker(cols[tickerIdx]);
        if (t) tickers.push(t);
      }
      return tickers;
    }

    function updateFileSummary() {
      if (!parsedFiles.length) {
        fileSummaryEl.style.display = "none";
        fileSummaryEl.innerHTML = "";
        return;
      }
      fileSummaryEl.style.display = "block";
      fileSummaryEl.innerHTML = "";
      parsedFiles.forEach((pf) => {
        const div = document.createElement("div");
        div.className = "file-summary-item";
        div.textContent = `${pf.name}: ${pf.tickers.length} tickers`;
        fileSummaryEl.appendChild(div);
      });
    }

    function readAllFiles(files) {
      parsedFiles = [];
      setStatus("", "");
      commaOutputEl.value = "";
      fileSummaryEl.style.display = "none";
      fileSummaryEl.innerHTML = "";

      if (!files || !files.length) {
        setStatus("No files selected yet.", "error");
        return;
      }

      let remaining = files.length;

      Array.from(files).forEach((file) => {
        const reader = new FileReader();
        reader.onload = () => {
          try {
            const text = reader.result;
            const tickers = parseCsvForTickers(text);
            parsedFiles.push({ name: file.name, tickers });
          } catch (e) {
            console.error(e);
            parsedFiles.push({
              name: file.name,
              tickers: [],
              error: e.message,
            });
          } finally {
            remaining--;
            if (remaining === 0) {
              // All files processed
              updateFileSummary();
              setStatus(
                "Files loaded. Click 'Aggregate tickers' to build the combined list.",
                "ok"
              );
            }
          }
        };
        reader.onerror = () => {
          console.error("Error reading file:", file.name);
          parsedFiles.push({
            name: file.name,
            tickers: [],
            error: "Failed to read file",
          });
          remaining--;
          if (remaining === 0) {
            updateFileSummary();
            setStatus(
              "Some files could not be read. Check the summary above.",
              "error"
            );
          }
        };
        reader.readAsText(file);
      });
    }

    filesInput.addEventListener("change", (e) => {
      readAllFiles(e.target.files);
    });

    aggregateBtn.addEventListener("click", () => {
      if (!parsedFiles.length) {
        setStatus("No files loaded â€“ select CSV files first.", "error");
        return;
      }

      const allTickers = parsedFiles.flatMap((pf) => pf.tickers || []);
      if (!allTickers.length) {
        setStatus(
          "No tickers found in the loaded files (check headers/format).",
          "error"
        );
        return;
      }

      const unique = Array.from(new Set(allTickers)).sort();
      commaOutputEl.value = unique.join(", ");

      setStatus(
        `Aggregated ${unique.length} unique tickers from ${allTickers.length} total entries.`,
        "ok"
      );
    });

    copyBtn.addEventListener("click", async () => {
      const text = commaOutputEl.value.trim();
      if (!text) {
        setStatus("Nothing to copy yet.", "error");
        return;
      }
      try {
        await navigator.clipboard.writeText(text);
        setStatus("Tickers copied to clipboard âœ…", "ok");
      } catch (e) {
        console.error(e);
        setStatus("Clipboard copy failed (browser blocked it).", "error");
      }
    });
  </script>
</body>
</html>
