<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ETF Holdings Aggregator â€“ BOUT + FFTY + QMOM (US Stocks Only)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      color: #111827;
      background: #f3f4f6;
    }
    body {
      margin: 0;
      padding: 24px 12px 40px;
      display: flex;
      justify-content: center;
    }
    .app {
      width: 100%;
      max-width: 900px;
      background: #ffffff;
      border-radius: 18px;
      padding: 24px 24px 32px;
      box-shadow: 0 16px 40px rgba(15, 23, 42, 0.12);
    }
    h1 {
      margin: 0 0 4px;
      font-size: 1.6rem;
    }
    .subtitle {
      margin: 0 0 20px;
      color: #6b7280;
      font-size: 0.95rem;
    }
    .small {
      font-size: 0.8rem;
      color: #6b7280;
    }
    .mt-4 { margin-top: 4px; }
    .mt-8 { margin-top: 8px; }
    .mt-16 { margin-top: 16px; }
    .mt-24 { margin-top: 24px; }
    .mt-32 { margin-top: 32px; }

    label {
      font-size: 0.85rem;
      font-weight: 600;
      display: block;
      margin-bottom: 6px;
    }

    input[type="file"] {
      font-size: 0.9rem;
    }

    button {
      border-radius: 999px;
      border: none;
      padding: 9px 18px;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      box-shadow: 0 8px 20px rgba(15, 23, 42, 0.12);
      transition: transform 0.1s, box-shadow 0.1s, background 0.1s;
    }
    button.primary {
      background: #4f46e5;
      color: #ffffff;
    }
    button.secondary {
      background: #e5e7eb;
      color: #111827;
      box-shadow: none;
    }
    button:active {
      transform: translateY(1px);
      box-shadow: 0 4px 10px rgba(15, 23, 42, 0.2);
    }

    textarea {
      width: 100%;
      border-radius: 10px;
      border: 1px solid #d1d5db;
      padding: 10px 12px;
      font-size: 0.9rem;
      box-sizing: border-box;
      min-height: 80px;
      resize: vertical;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      background: #f9fafb;
    }
    textarea:focus {
      outline: none;
      border-color: #4f46e5;
      box-shadow: 0 0 0 1px rgba(79, 70, 229, 0.4);
      background: #ffffff;
    }

    .status {
      margin-top: 6px;
      font-size: 0.83rem;
    }
    .status.error { color: #b91c1c; }
    .status.ok { color: #15803d; }

    .file-summary {
      margin-top: 8px;
      padding: 8px 10px;
      border-radius: 10px;
      background: #f9fafb;
      border: 1px solid #e5e7eb;
      font-size: 0.8rem;
    }
    .file-summary-item {
      margin-bottom: 4px;
    }

    @media (max-width: 640px) {
      .app {
        padding: 18px 14px 24px;
        border-radius: 0;
        box-shadow: none;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <h1>ETF Holdings Aggregator</h1>
    <p class="subtitle">
      Upload:
      <br>â€¢ <strong>xt_holdings.csv</strong> (we take only <strong>Account = BOUT, FFTY</strong>)
      <br>â€¢ plus any simple ETF holdings files (e.g. <strong>QMOM Holdings.csv</strong> with a Ticker column).
      <br>
      The tool returns a union of <strong>U.S. common-stock tickers</strong>, comma-separated (no quotes).
    </p>

    <div>
      <label for="filesInput">Holdings CSV files</label>
      <input
        type="file"
        id="filesInput"
        accept=".csv,.txt"
        multiple
      />
      <p class="small mt-4">
        â€¢ If a file has columns <code>Date, Account, StockTicker, CUSIP, SecurityName, MoneyMarketFlag</code>,
          it is treated as <code>xt_holdings</code> and only rows where
          <strong>Account = BOUT or FFTY</strong> are used.
        <br>â€¢ Any file with a <code>Ticker</code> / <code>Symbol</code> column is treated as a simple
          holdings file (e.g. QMOM), and all rows are used.
        <br>â€¢ In all cases, we then filter to <strong>U.S.-style common stocks</strong>
          (no ETFs, swaps/options, bonds/T-bills, money market, cash, ADR/foreign common, etc.).
      </p>

      <div id="fileSummary" class="file-summary" style="display:none;"></div>

      <div class="mt-16">
        <button id="aggregateBtn" class="primary">ðŸ”„ Aggregate U.S. common stocks</button>
        <span id="status" class="status"></span>
      </div>
    </div>

    <div class="mt-32">
      <h2 style="font-size:1.15rem; margin:0 0 8px;">Comma-separated U.S. stocks</h2>
      <p class="small" style="margin:0 0 8px;">
        Unique tickers across BOUT + FFTY (from xt_holdings) and other uploaded ETFs (like QMOM).
        Sorted alphabetically, no quotes.
      </p>

      <label for="commaOutput" style="margin-bottom:4px;">Output</label>
      <textarea id="commaOutput" placeholder="AAPL, MSFT, NVDA, ..."></textarea>

      <div class="mt-8">
        <button id="copyBtn" class="secondary">
          ðŸ“‹ Copy comma-separated tickers
        </button>
      </div>
    </div>
  </div>

  <script>
    const filesInput = document.getElementById("filesInput");
    const aggregateBtn = document.getElementById("aggregateBtn");
    const copyBtn = document.getElementById("copyBtn");
    const statusEl = document.getElementById("status");
    const fileSummaryEl = document.getElementById("fileSummary");
    const commaOutputEl = document.getElementById("commaOutput");

    let parsedFiles = [];

    function setStatus(msg, type = "") {
      statusEl.textContent = msg || "";
      statusEl.className = "status" + (type ? " " + type : "");
    }

    // --- Core normalization / filters ---

    function normalizeEquityTicker(raw) {
      if (!raw) return null;
      let t = String(raw).trim();
      if (!t) return null;

      if (
        (t.startsWith('"') && t.endsWith('"')) ||
        (t.startsWith("'") && t.endsWith("'"))
      ) {
        t = t.slice(1, -1).trim();
      }
      if (!t) return null;

      let base = t.split(/\s+/)[0].trim().toUpperCase();
      if (!base) return null;

      const blacklistExact = new Set(["CASH", "OTHER", "CASH&OTHER", "NA"]);
      if (blacklistExact.has(base)) return null;
      if (base.includes("&")) return null;

      const shareClassSlash = /^[A-Z]{1,4}\/[A-Z]$/;
      const simpleEquity = /^[A-Z]{1,5}$/;

      if (/XXX$/.test(base)) return null;

      if (shareClassSlash.test(base)) return base;
      if (!simpleEquity.test(base)) return null;

      return base;
    }

    function isLikelyNonEquity(ticker, name, mmFlag, cusip) {
      const n = (name || "").toUpperCase();
      const mm = (mmFlag || "").toUpperCase().trim();
      const c = (cusip || "").toUpperCase().trim();

      // Money market / cash
      if (mm && /^(Y|YES|1|TRUE)$/.test(mm)) return true;
      if (/\b(CASH|MONEY\s*MARKET|MMF|LIQUIDITY)\b/.test(n)) return true;

      // US Treasuries / bills
      if (/\b(TREASURY|T-BILL|TBILL|T BILL)\b/.test(n)) return true;
      if (c.startsWith("9127")) return true;

      // ETFs / funds
      if (/\bETF\b/.test(n)) return true;
      const etfWords = [
        "SPDR", "SPDRÂ®", "ISHARES", "VANGUARD", "POWERSHARES",
        "XTRACKERS", "WISDOMTREE", "INDEX FUND", "UCITS ETF",
        "EXCHANGE TRADED FUND", "FUND TRUST"
      ];
      for (const w of etfWords) {
        if (n.includes(w)) return true;
      }

      // Derivatives
      if (/\b(SWAP|SWP|TRS|TOTAL RETURN|FUTURE|FUTURES|FORWARD|FWD|OPTION|CALL|PUT|WARRANT|RIGHTS?)\b/.test(n)) {
        return true;
      }

      // Debt / preferred
      if (/\b(BOND|NOTE|DEBENTURE|PFD|PREFERRED)\b/.test(n)) return true;

      if (/\bINDEX\b/.test(n) && !/\bCORP\b/.test(n)) return true;

      return false;
    }

    function isLikelyNonUSCommon(ticker, name, cusip) {
      const n = (name || "").toUpperCase();

      if (/\b(ADR|ADS|GDR|SP ADR|UNSPONSORED)\b/.test(n)) return true;
      if (/\b(ORDINARY|ORD SHS|ORD SHARES|ORD)\b/.test(n)) return true;
      if (/\b(PLC|S\.?A\.?|N\.?V\.?|AG|BV|OYJ|S\.P\.A\.?|SPA)\b/.test(n)) {
        return true;
      }

      return false;
    }

    // --- CSV helpers ---

    function detectDelimiter(lines) {
      const candidates = [",", ";", "\t"];
      const scores = { ",": 0, ";": 0, "\t": 0 };
      const sampleLines = lines.slice(0, Math.min(lines.length, 10));
      for (const line of sampleLines) {
        for (const d of candidates) {
          const c = (line.match(new RegExp(`\\${d}`, "g")) || []).length;
          scores[d] += c;
        }
      }
      let best = ",";
      let bestScore = -1;
      for (const d of candidates) {
        if (scores[d] > bestScore) {
          bestScore = scores[d];
          best = d;
        }
      }
      return best;
    }

    // --- xt_holdings-specific parser (BOUT + FFTY only) ---

    function parseXtHoldingsFile(text) {
      const rawLines = text.split(/\r?\n/);
      const lines = rawLines.filter((l) => l.trim());
      if (!lines.length) return [];

      const delimiter = detectDelimiter(lines);
      const headerLine = lines[0];
      const headerCols = headerLine.split(delimiter).map((c) => c.trim());

      // Expect exact xt_holdings headers
      const accountIdx = headerCols.indexOf("Account");
      const tickerIdx = headerCols.indexOf("StockTicker");
      const nameIdx = headerCols.indexOf("SecurityName");
      const cusipIdx = headerCols.indexOf("CUSIP");
      const mmIdx = headerCols.indexOf("MoneyMarketFlag");

      if (accountIdx === -1 || tickerIdx === -1 || nameIdx === -1) {
        // Not xt_holdings, bail
        return null;
      }

      const allowedAccounts = new Set(["BOUT", "FFTY"]);
      const tickers = [];

      for (let i = 1; i < lines.length; i++) {
        const cols = lines[i].split(delimiter);
        if (!cols.length) continue;

        const rawAccount = cols[accountIdx] || "";
        const acct = rawAccount.toString().trim().toUpperCase();
        if (!allowedAccounts.has(acct)) continue;

        const rawTicker = cols[tickerIdx];
        const rawName = cols[nameIdx] || "";
        const rawCusip = cusipIdx >= 0 && cusipIdx < cols.length ? cols[cusipIdx] : "";
        const rawMM = mmIdx >= 0 && mmIdx < cols.length ? cols[mmIdx] : "";

        const eqTicker = normalizeEquityTicker(rawTicker);
        if (!eqTicker) continue;

        if (isLikelyNonEquity(eqTicker, rawName, rawMM, rawCusip)) continue;
        if (isLikelyNonUSCommon(eqTicker, rawName, rawCusip)) continue;

        tickers.push(eqTicker);
      }

      return tickers;
    }

    // --- Generic holdings parser (for QMOM-style CSVs) ---

    function parseGenericHoldingsFile(text) {
      const rawLines = text.split(/\r?\n/);
      const lines = rawLines.filter((l) => l.trim());
      if (!lines.length) return [];

      const delimiter = detectDelimiter(lines);
      const headerCols = lines[0].split(delimiter).map((c) => c.trim());

      // Locate a ticker-like column: Ticker, Symbol, etc.
      let tickerIdx = headerCols.findIndex((h) =>
        /^(ticker|symbol)$/i.test(h)
      );
      if (tickerIdx === -1) {
        // nothing sensible
        return [];
      }

      // Optional name / cusip / mmflag columns
      const nameIdx = headerCols.findIndex((h) =>
        /(security\s*name|name|description)/i.test(h)
      );
      const cusipIdx = headerCols.findIndex((h) => /cusip/i.test(h));
      const mmIdx = headerCols.findIndex((h) =>
        /(moneymarketflag|money\s*market|mmflag)/i.test(h)
      );

      const tickers = [];

      for (let i = 1; i < lines.length; i++) {
        const cols = lines[i].split(delimiter);
        if (!cols.length || tickerIdx >= cols.length) continue;

        const rawTicker = cols[tickerIdx];
        const rawName =
          nameIdx >= 0 && nameIdx < cols.length ? cols[nameIdx] : "";
        const rawCusip =
          cusipIdx >= 0 && cusipIdx < cols.length ? cols[cusipIdx] : "";
        const rawMM =
          mmIdx >= 0 && mmIdx < cols.length ? cols[mmIdx] : "";

        const eqTicker = normalizeEquityTicker(rawTicker);
        if (!eqTicker) continue;

        if (isLikelyNonEquity(eqTicker, rawName, rawMM, rawCusip)) continue;
        if (isLikelyNonUSCommon(eqTicker, rawName, rawCusip)) continue;

        tickers.push(eqTicker);
      }

      return tickers;
    }

    // --- File orchestration ---

    function updateFileSummary() {
      if (!parsedFiles.length) {
        fileSummaryEl.style.display = "none";
        fileSummaryEl.innerHTML = "";
        return;
      }
      fileSummaryEl.style.display = "block";
      fileSummaryEl.innerHTML = "";
      parsedFiles.forEach((pf) => {
        const div = document.createElement("div");
        div.className = "file-summary-item";
        if (pf.error) {
          div.textContent = `${pf.name}: error â€“ ${pf.error}`;
        } else {
          div.textContent = `${pf.name}: ${pf.tickers.length} U.S. common-stock tickers after filtering`;
        }
        fileSummaryEl.appendChild(div);
      });
    }

    function readAllFiles(files) {
      parsedFiles = [];
      setStatus("", "");
      commaOutputEl.value = "";
      fileSummaryEl.style.display = "none";
      fileSummaryEl.innerHTML = "";

      if (!files || !files.length) {
        setStatus("No files selected yet.", "error");
        return;
      }

      let remaining = files.length;

      Array.from(files).forEach((file) => {
        const reader = new FileReader();
        reader.onload = () => {
          try {
            const text = reader.result;
            // First try xt_holdings parser
            let tickers = parseXtHoldingsFile(text);
            if (tickers === null) {
              // Not xt_holdings; use generic (QMOM-style) parser
              tickers = parseGenericHoldingsFile(text);
            }
            parsedFiles.push({ name: file.name, tickers });
          } catch (e) {
            console.error(e);
            parsedFiles.push({
              name: file.name,
              tickers: [],
              error: e.message,
            });
          } finally {
            remaining--;
            if (remaining === 0) {
              updateFileSummary();
              if (parsedFiles.some((pf) => (pf.tickers || []).length > 0)) {
                setStatus(
                  "Files loaded. Click 'Aggregate U.S. common stocks' to build the combined list.",
                  "ok"
                );
              } else {
                setStatus(
                  "Files loaded but no U.S. common stocks detected â€“ check that the files are xt_holdings or QMOM-style holdings CSVs.",
                  "error"
                );
              }
            }
          }
        };
        reader.onerror = () => {
          console.error("Error reading file:", file.name);
          parsedFiles.push({
            name: file.name,
            tickers: [],
            error: "Failed to read file",
          });
          remaining--;
          if (remaining === 0) {
            updateFileSummary();
            setStatus(
              "Some files could not be read. Check the summary above.",
              "error"
            );
          }
        };
        reader.readAsText(file);
      });
    }

    filesInput.addEventListener("change", (e) => {
      readAllFiles(e.target.files);
    });

    aggregateBtn.addEventListener("click", () => {
      if (!parsedFiles.length) {
        setStatus("No files loaded â€“ select CSV files first.", "error");
        return;
      }

      const allTickers = parsedFiles.flatMap((pf) => pf.tickers || []);
      if (!allTickers.length) {
        setStatus(
          "No U.S. common stocks found in the loaded files.",
          "error"
        );
        return;
      }

      const unique = Array.from(new Set(allTickers)).sort();
      commaOutputEl.value = unique.join(", ");

      setStatus(
        `Aggregated ${unique.length} unique U.S. common-stock tickers from ${allTickers.length} rows after filtering.`,
        "ok"
      );
    });

    copyBtn.addEventListener("click", async () => {
      const text = commaOutputEl.value.trim();
      if (!text) {
        setStatus("Nothing to copy yet.", "error");
        return;
      }
      try {
        await navigator.clipboard.writeText(text);
        setStatus("Tickers copied to clipboard âœ…", "ok");
      } catch (e) {
        console.error(e);
        setStatus("Clipboard copy failed (browser blocked it).", "error");
      }
    });
  </script>
</body>
</html>
